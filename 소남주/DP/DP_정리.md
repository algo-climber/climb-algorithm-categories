# DP (Dynamic Programming)

## 🏷 INTRO
- DP란, 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것
- 알고리즘이라기 보다는, 하나의 문제해결 방법
<br/>

## 🏷 사용 조건
### 1. Overlapping Subproblems (겹치는 부분 문제)
- 동일한 작은 문제들이 반복하여 나타나는 경우
- ex. 피보나치 수열

### 2. Optimal Substructure (최적 부분 구조)
- 부분 문제의 최적 결과 값을 사용하여 전체 문제의 최적 결과를 낼 수 있는 경우
- ex. 최단 경로
<br/>

## 🏷 풀이 방법
1. DP로 풀 수 있는 문제인 지 조건 확인
2. 변수 파악
3. 변수 간 관계식 만들기 (점화식)
4. 메모하기 (memoizatino or tabulation)
5. 기저 상태 파악
6. 구현
<br/>

## 🏷 구현 방법
### 1. Bottom-Up (Tabulation) - 반복문
- 아래에서부터 계산을 수행하고, 누적시켜서 큰 문제를 해결하는 방식
- 반복을 통해 `dp[0]`부터 하나씩 채우는 과정을 `table-filling`이라고 하며, 이 table에 저장된 값에 직접 접근하여 재활용하기 때문에, `Tabulation`이라고 한다.

### 2. Top-Down (Memoization) - 재귀
- 위에서부터 바로 호출을 시작하여, `dp[0]` 상태까지 내려간 다음, 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식
- 이전에 계산을 완료한 경우에는 바로 쓸 수 있도록 memoization을 한다.
<br/>

## 🏷 DP vs. Divide and Conquer
### 공통점
- 주어진 문제를 작게 쪼개서 하위 문제로 해결하고, 연계적으로 큰 문제를 해결한다

### 차이점
- Divide and Conquer : 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 사용
- DP : 분할된 하위 문제가 동일한 중복이 일어나는 경우에 사용