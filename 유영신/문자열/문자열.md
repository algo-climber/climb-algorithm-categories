## 문자열 문제를 풀면서 느낀 점과 알게 된 점

### 1. **백준 17609 - 회문**
이 문제는 주어진 문자열이 회문인지, 한 글자를 삭제해서 회문으로 만들 수 있는지 확인하는 문제이다. 회문은 양쪽 끝에서 같은 문자를 가지고 있는 문자열을 뜻하는데, 이전에 푼문제에서는 단순 회문만 찾으면 됐었는데, 문자열이 회문이 아니더라도 한 글자만 지우면 회문이 될 수 있는 **유사회문**의 경우를 처리해야 했다.

코드에서는 먼저 문자열이 회문인지 확인한 후, 회문이 아니라면 왼쪽과 오른쪽에서 각각 한 글자씩 제거해보며 회문 여부를 다시 확인했다. `checkLeft()`와 `checkRight()` 함수가 각각 왼쪽과 오른쪽을 삭제한 후 회문인지 검사하는 부분이다.

**알게 된 점**: 회문 검사는 비교적 간단한 문제였지만, 회문이 아닌 경우 유사회문을 처리하는 데 있어 세심한 예외 처리가 필요하다는 것을 알게 되었다. 특히 양쪽 끝에서 하나씩 문자를 비교하다가 불일치가 발생했을 때, 어느 쪽을 먼저 지우고 다시 확인해야 할지를 왼쪽과 오른쪽을 나누어 처리해야 했다.

**느낀 점**: 처음에는 단순히 회문인지 여부만 판단하면 될 것이라 생각했지만, 유사회문 조건을 만족시키기 위해 두 방향에서의 검사(`checkLeft`, `checkRight`)가 필요하다는 점에서 코드가 더 복잡해졌다. 특히 `countL`, `countR` 변수를 통해 각각 왼쪽과 오른쪽에서 문자를 제거한 횟수를 기록하고, 이 횟수가 1회 이내일 때만 유사회문으로 처리하는 부분이 까다로웠던 것 같다.

---

### 2. **백준 9935 - 문자열 폭발**
이 문제는 문자열에서 특정 패턴(폭발 문자열)이 나타날 때 그 부분을 삭제하는 방식으로, 폭발 문자열이 발생할 때마다 문자열을 실시간으로 수정해야 했다. 이를 위해 **스택**을 사용하여 문제를 해결하였다. 문자열을 한 글자씩 스택에 쌓아가면서, 스택의 마지막 부분이 폭발 문자열과 일치할 경우 해당 문자열을 삭제하는 방식이다.

코드에서는 `stack`을 사용하여 문자열을 처리하며, 스택에 폭발 문자열이 쌓였는지 확인하는 과정을 반복하고, 폭발 문자열이 쌓이면 그 길이만큼 스택에서 `pop()` 하여 제거해주었다. 마지막에는 스택에 남은 문자열을 `StringBuilder`로 반환해 결과를 출력해주었는데, stack에서 `pop()`할때는 순서가 반대로 나오기 때문에 `sb.reverse()`를 사용했다.

**알게 된 점**: 스택을 사용한 이 방식은 문자열을 바로바로 처리할 때 매우 유용하다는 것을 깨달았다. 만약 스택을 사용하지 않고 문자열을 매번 처음부터 확인했다면, 시간 복잡도가 기하급수적으로 증가했을 것 같다.

**느낀 점**: 처음에는 문자열을 탐색하면서 폭발 문자열을 찾는 단순한 반복문을 생각했지만, 그렇게 하면 폭발이 일어날 때마다 문자열 전체를 다시 탐색해야 했기 때문에 시간 복잡도가 O(n^2) 이상이 될 수 있었다. 시간 복잡도를 낮추기 위해 스택을 사용하여 필요한 부분만 수정하는 방식이 매우 효과적이었고, 자료구조 선택이 문제 해결에서 얼마나 중요한지를 깨달았다.